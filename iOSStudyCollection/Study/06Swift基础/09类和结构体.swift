//
//  09类和结构体.swift
//  iOSStudyCollection
//
//  Created by 赵赫 on 2018/5/3.
//  Copyright © 2018年 赵赫. All rights reserved.
//

import UIKit

class Normal09: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        
        /** 结构体会有一个默认的成员逐一构造器，但Class没有 */
        let a = Struct1(a: 10, b: 20)
        let b = Class1()
        
        
        
        
        /** 结构体是值类型，在赋值时，值会被拷贝 */
        /** Int、String、Array等都是结构体实现的，所以在传递过程中，也都是拷贝的 */
        /** 枚举也是值类型的 */
        
        
        
        
        /** === 与 !== */
        let c = Class1()
        let d = c
        print(c === d)  // 通过 === !== 判断两个变量或常量引用的是否是同一个类实例
        // == 是判断值是否相等，由开发者规定==成立的规则，比如可以规定：两个不同的Array，两个Array中的元素个数相等时==成立，则==遵循这样的规则去判断等式是否成立
        
        
        
        /* 按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体：
        
        该数据结构的主要目的是用来封装少量相关简单数据值。
        有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。
        该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。
        该数据结构不需要去继承另一个既有类型的属性或者行为。
        举例来说，以下情境中适合使用结构体：
        
        几何形状的大小，封装一个width属性和height属性，两者均为Double类型。
        一定范围内的路径，封装一个start属性和length属性，两者均为Int类型。
        三维坐标系内一点，封装x，y和z属性，三者均为Double类型。 */
        
        
        /*
        Swift 中，许多基本类型，诸如String，Array和Dictionary类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。
        
        Objective-C 中NSString，NSArray和NSDictionary类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。
         */
    }
    
    
/*    Swift 中类和结构体有很多共同点。共同处在于：
    
    定义属性用于存储值
    定义方法用于提供功能
    定义下标操作使得可以通过下标语法来访问实例所包含的值
    定义构造器用于生成初始化值
    通过扩展以增加默认实现的功能
    实现协议以提供某种标准功能
    更多信息请参见属性，方法，下标，构造过程，扩展，和协议。
    
    与结构体相比，类还有如下的附加功能：
    
    继承允许一个类继承另一个类的特征
    类型转换允许在运行时检查和解释一个类实例的类型
    析构器允许一个类实例释放任何其所被分配的资源
    引用计数允许对一个类的多次引用
    更多信息请参见继承，类型转换，析构过程，和自动引用计数。
    
    注意
    结构体总是通过被复制的方式在代码中传递，不使用引用计数。
*/
}



struct Struct1 {
    var a = 0
    var b = 0
}

class Class1 {
    var a = 0
    var b = 0
}
